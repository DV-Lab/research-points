<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DV-Lab&#x27;s Research Points</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="zkp/index.html"><strong aria-hidden="true">2.</strong> Zero Knowledge Proofs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zkp/overview.html"><strong aria-hidden="true">2.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="zkp/proving.html"><strong aria-hidden="true">2.2.</strong> Proving</a></li><li class="chapter-item expanded "><a href="zkp/snarks/index.html"><strong aria-hidden="true">2.3.</strong> Introduction to zk-SNARKs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zkp/snarks/bellman.html"><strong aria-hidden="true">2.3.1.</strong> Demo with zkcrypto bellman</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DV-Lab&#x27;s Research Points</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>From a thesis in <a href="https://hcmut.edu.vn/">Ho Chi Minh University of Technology</a></p>
<p>Hello super star :v:</p>
<p>Hope you love this document...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-knowledge-proofs"><a class="header" href="#zero-knowledge-proofs">Zero Knowledge Proofs</a></h1>
<h2 id="the-first-rule-of-modern-cryptography-is-never-to-trust-people-who-claim-such-things-without-proof"><a class="header" href="#the-first-rule-of-modern-cryptography-is-never-to-trust-people-who-claim-such-things-without-proof">&quot;The first rule of modern cryptography is never to trust people who claim such things without proof.&quot;</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>The notion of <strong>zero knowledge</strong> was first proposed in the 1980s by MIT researchers Shafi Goldwasser, Silvio Micali and Charles Rackoff. 
That time, most work in this area focused the <strong>soundness</strong> of the proof system. It considered the case where a malicious <strong>Prover</strong> attempts to ‘trick’ a <strong>Verifier</strong> into believing a false statement: What happens if you don’t trust the Verifier?</p>
<blockquote>
<p><em><strong>Soundness</strong></em>: you should follow <a href="https://www.amazon.com/Logic-Computer-Science-Modelling-Reasoning/dp/052154310X">this book</a> - chapter <strong>1.4 Semantics of propositional logic</strong> (p.45, p.49)</p>
</blockquote>
<h3 id="the-problems"><a class="header" href="#the-problems">The problems</a></h3>
<p>How much extra information is the Verifier going to learn during the course of this proof, thus this statement is true?</p>
<p>Let's see an example. In most real systems (2023), when logging, the clients input their password, then the &quot;raw passwords&quot; were transmitted to the server. Servers will calculate (most, put them into hash function) passwords, then compare &quot;encoded passwords&quot; with &quot;also encoded passwords&quot; stored in database.</p>
<p>-&gt; Why servers have privilege to know client's info, whether hackers can take advantage of this to analysis the habit of creating the clients's passwords?</p>
<h3 id="a-real-world-example"><a class="header" href="#a-real-world-example">A &quot;real world&quot; example</a></h3>
<p>Imagine the network structure is represented by the graph below.Each vertex in this graph represents a telecom tower. The connecting lines (edges) indicate tower's transmissions are likely to interfere with each other.</p>
<img src="zkp/./assets/telecom-towers.png" alt="Telecom Tower" style="width:50%; display: block; margin-left: auto;  margin-right: auto;">
<p>If adjacent towers use the same bandwidth, it can be conflicted
So if we use three different frequency, the network will work normally. Theory problem called the graph three-coloring problem.</p>
<img src="zkp/./assets/telecom-towers-colored.png" alt="Telecom Tower Colored" style="width:50%; display: block; margin-left: auto;  margin-right: auto;">
<p>If this network was very large and complex, so much so that the computing power at my disposal was not sufficient to find a solution. In this instance, I might hire my friends at Google to solve it for me on spec.</p>
<p>But this leads to a problem.</p>
<p>Suppose that Google devotes a large percentage of their computing infrastructure to searching for a valid coloring for my graph. I’m certainly not going to pay them until I know that they really have such a coloring.</p>
<p>At the same time, Google isn’t going to give me a copy of their solution until I’ve paid up. We’ll wind up at an impasse.</p>
<h3 id="a-crazy-technical-solution-with-hats"><a class="header" href="#a-crazy-technical-solution-with-hats">A crazy technical solution (with hats!)</a></h3>
<p>The solution includes some concepts:</p>
<ol>
<li>Google cover all tower with <strong>hats</strong>, make sure the client not have info about the color of each tower.</li>
<li>When the client testing, Google will show randomly some towers and their colors that proved Google is not lying.</li>
<li>The loop will be ended util step <strong>2</strong> made enough large (~ E^2), so client can be confident to pay money for Google</li>
</ol>
<img src="zkp/./assets/hats.png" alt="Telecom Tower Colored" style="width:50%; display: block; margin-left: auto;  margin-right: auto;">
<blockquote>
<p>Please follow <a href="https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/">main article</a> 
for more information.</p>
</blockquote>
<h3 id="what-makes-it-zero-knowledge"><a class="header" href="#what-makes-it-zero-knowledge">What makes it <strong>&quot;zero knowledge&quot;</strong>?</a></h3>
<p>The first rule of modern cryptography is never to trust people who claim such things without proof.</p>
<p>Goldwasser, Micali and Rackoff proposed three following properties that every zero-knowledge protocol must satisfy. Stated informally, they are:</p>
<ol>
<li>
<p><strong>Completeness</strong>: If Google is telling the truth, then they will eventually convince me (at least with high probability).</p>
</li>
<li>
<p><strong>Soundness</strong>: Google can only convince me if they’re actually telling the truth.</p>
</li>
<li>
<p><strong>Zero-knowledgeness</strong>: I don’t learn anything else about Google’s solution. (hard part, we need to conduct a very strange thought experiment.)</p>
</li>
</ol>
<blockquote>
<p><strong>Completeness</strong> and <strong>Soundness</strong>: you should follow <a href="https://www.amazon.com/Logic-Computer-Science-Modelling-Reasoning/dp/052154310X">this book</a> - chapter <strong>1.4 Semantics of propositional logic</strong> (p.45, p.49)</p>
</blockquote>
<h3 id="a-thought-experiment-with-time-machines"><a class="header" href="#a-thought-experiment-with-time-machines">A thought experiment (with time machines)</a></h3>
<p>There is an example of <code>simulation</code>. Imagine that Google doesn’t actually know a valid coloring for the graph. Whenever I pull off a pair of hats, there is a designated Googler pulls a switch, ‘rewinds’ time about four minutes, and the Google team recolors the graph with a completely new random solution. Now they let time roll forward and try again. It called time machine. From my perspective I don’t even know that the extra time machine trips are happening.</p>
<h3 id="what-the-hell-is-the-point-of-this"><a class="header" href="#what-the-hell-is-the-point-of-this">What the hell is the point of this?</a></h3>
<p>Note that in a world where time runs only forward and nobody can trick me with a time machine, the hat-based protocol is correct and sound, meaning that after E^2 rounds I should be convinced (with all but negligible probability) that the graph really is colorable and that Google is putting valid inputs into the protocol.</p>
<p>If time doesn’t run only forward, if Google can ‘rewind’ my view of time — then they can fake a valid protocol run even if they have no information at all about the actual graph coloring?</p>
<p>From my perspective, what’s the difference between the two protocol transcripts? When we consider the statistical distribution of the two, there’s no difference at all. Both convey exactly the same amount of useful information.</p>
<p>Specifically, assume that I (the Verifier) have some strategy that ‘extracts’ useful information about Google’s coloring after observing an execution of the honest protocol. Then my strategy should work equally well in the case where I’m being fooled with a time machine. The protocol runs are, from my perspective, statistically identical. I physically cannot tell the difference.</p>
<p>Thus if the amount of information I can extract is identical in the ‘real experiment’ and the ‘time machine experiment’, yet the amount of information Google puts into the ‘time machine’ experiment is exactly zero — then this implies that even in the real world the protocol must not leak any useful information.</p>
<h3 id="getting-rid-of-the-hats-and-time-machines"><a class="header" href="#getting-rid-of-the-hats-and-time-machines">Getting rid of the hats (and time machines)</a></h3>
<p>Of course we don’t actually want to run a protocol with hats. And even Google (probably?) doesn’t have a literal time machine.</p>
<p>To tie things together, we first need to bring our protocol into the digital world. This requires that we construct the digital equivalent of a ‘hat’: <em><strong>something</strong></em> that both hides a digital value, while simultaneously ‘binding’ (or ‘committing’) the maker to it, so she can’t change her mind after the fact.</p>
<p>Fortunately we have a perfect tool for this application. It’s called a digital commitment scheme. A commitment scheme allows one party to ‘commit’ to a given message while keeping it secret, and then later ‘open’ the resulting commitment to reveal what’s inside. They can be built out of various ingredients, including (strong) cryptographic hash functions.</p>
<p>Given a commitment scheme, we now have all the ingredients we need to run the zero knowledge protocol electronically. The Prover first encodes its vertex colorings as a set of digital messages (for example, the numbers 0, 1, 2), then generates digital commitments to each one. These commitments get sent over to the Verifier. When the Verifier challenges on an edge, the Prover simply reveals the opening values for the commitments corresponding to the two vertices.</p>
<img src="zkp/./assets/commitment-scheme.png" alt="commitment-scheme" style="width:50%; display: block; margin-left: auto;  margin-right: auto;">
<p>So we’ve managed to eliminate the hats. But how do we prove that this protocol is <strong>&quot;zero knowledge&quot;</strong>?</p>
<p>Fortunately now that we’re in the digital world, we no longer need a real time machine to prove things about this protocol. A key trick is to specify in our setting that the protocol is not going to be run between two people, but rather between two different computer programs (or, to be more formal, probabilistic Turing machines.)</p>
<p>What we can now prove is the following theorem: if you could ever come up with a computer program (for the Verifier) that extracts useful information after participating in a run of the protocol, then it would be possible to use a ‘time machine’ on that program in order to make it extract the same amount of useful information from a ‘fake’ run of the protocol where the Prover doesn’t put in any information to begin with.</p>
<p><code>Ultimately what we get is the following theorem. If there exists any Verifier computer program that successfully extracts information by interactively running this protocol with some Prover, then we can simply use the rewinding trick on that program to commit to a random solution, then ‘trick’ the Verifier by rewinding its execution whenever we can’t answer its challenge correctly. The same logic holds as we gave above: if such a Verifier succeeds in extracting information after running the real protocol, then it should be able to extract the same amount of information from the simulated, rewinding-based protocol. But since there’s no information going into the simulated protocol, there’s no information to extract. Thus the information the Verifier can extract must always be zero.</code></p>
<h3 id="so-what-does-this-all-mean"><a class="header" href="#so-what-does-this-all-mean">So what does this all mean?</a></h3>
<p>We know that the protocol is complete and sound, based on our analysis above. The soundness argument holds in any situation where we know that nobody is fiddling with time — that is, the Verifier is running normally and nobody is rewinding its execution.</p>
<p>At the same time, the protocol is also zero knowledge. To prove this, we showed that any Verifier program that succeeds in extracting information must also be able to extract information from a protocol run where rewinding is used and no information is available in the first place. Which leads to an obvious contradiction, and tells us that the protocol can’t leak information in either situation.</p>
<p>There’s an important benefit to all this. Since it’s trivial for anyone to ‘fake’ a protocol transcript, even after Google proves to me that they have a solution, I can’t re-play a recording of the protocol transcript to prove anything to anyone else (say, a judge). That’s because the judge would have no guarantee that the video was recorded honestly, and that I didn’t simply edit in the same way Google might have done using the time machine. This means that protocol transcripts themselves contain no information. The protocol is only meaningful if I myself participated, and I can be sure that it happened in real time.</p>
<h1 id="proving-section-will-be-updated"><a class="header" href="#proving-section-will-be-updated">Proving section will be updated....</a></h1>
<p><a href="https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/">Ref</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proving"><a class="header" href="#proving">Proving</a></h1>
<h1 id="updating"><a class="header" href="#updating">Updating....</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-zk-snarks"><a class="header" href="#introduction-to-zk-snarks">Introduction to zk-SNARKs</a></h1>
<blockquote>
<p>SNARK = Succinct Non-interactive ARguments of Knowledge</p>
</blockquote>
<blockquote>
<p>For brief</p>
</blockquote>
<h2 id="zero-knowledge-proofs-1"><a class="header" href="#zero-knowledge-proofs-1">Zero-knowledge proofs</a></h2>
<p>The goal of zero-knowledge proofs is for a verifier to be able to convince herself that a prover possesses knowledge of a secret parameter, called a witness, satisfying some relation, without revealing the witness to the verifier or anyone else.</p>
<p>We can think of this more concretely as having a program, denoted <code>C</code> (commitment), taking two inputs: <code>C(x, w)</code>. The input <code>x</code> is the public input, and <code>w</code> is the secret witness input. The output of the program is <code>boolean</code>, i.e. either true or false. The goal then is given a specific public input x, prove that the prover knows a secret input <code>w</code> such that <code>C(x,w) == true</code>.</p>
<p>We are specifically going to discuss <code>non-interactive zero knowledge proofs</code>, which means that the proof itself is a blob of data that can be verified without any interaction from the prover.</p>
<h2 id="example-program"><a class="header" href="#example-program">Example program</a></h2>
<p>Suppose Bob is given a hash <code>H</code> of some value, and he wishes to have a proof that Alice knows the value <code>s</code> that hashes to H. <strong>Normally</strong> Alice would prove this by giving <code>s</code> to Bob, after which Bob would compute the hash and check that it equals <code>H</code>.</p>
<p>However, suppose Alice doesn’t want to reveal the value <code>s</code> to Bob but instead she just wants to prove that she knows the value. She can use a <code>zk-SNARK</code> for this.</p>
<p>We can describe Alice’s scenario using the following program, here written as a Javascript function:</p>
<pre><code class="language-js">function C(x, w) {
  return ( sha256(w) == x );
}
</code></pre>
<p>In other words: the program takes in a public hash <code>x</code> and a secret value <code>w</code> and returns true if the <code>SHA–256</code> hash of <code>w</code> equals <code>x</code>.</p>
<p>Translating Alice’s problem using the <code>function C(x,w)</code> we see that Alice needs to create a <strong>proof</strong> that she possesses <code>s</code> such that <code>C(H, s) == true</code>, without having to reveal <code>s</code>. </p>
<p>A zk-SNARK consists of three algorithms <code>G, P, V</code> defined as follows:</p>
<p>The key generator <code>G</code> takes a secret parameter <code>lambda</code> and a program <code>C</code>, and generates two publicly available keys, a proving key <code>pk</code>, and a verification key <code>vk</code>. These keys are public parameters that only need to be generated once for a given program <code>C</code>.</p>
<p>The prover <code>P</code> takes as input the proving key <code>pk</code>, a public input <code>x</code> and a private witness <code>w</code>. The algorithm generates a proof <code>prf = P(pk, x, w)</code> that the prover knows a witness w and that the witness satisfies the program.</p>
<p>The verifier <code>V</code> computes <code>V(vk, x, prf)</code> which returns <code>true</code> if the proof is correct, and <code>false</code> otherwise. Thus this function returns <code>true</code> if the prover knows a witness <code>w</code> satisfying <code>C(x,w) == true</code>.</p>
<p>Note here the secret parameter <code>lambda</code> used in the generator. This parameter sometimes makes it tricky to use <code>zk-SNARKs</code> in real-world applications. The reason for this is that anyone who knows this parameter can generate <em><strong>fake proofs</strong></em>. Specifically, given any program <code>C</code>and public input <code>x</code> a person who knows <code>lambda</code> can generate a proof <code>fake_prf</code> such that <code>V(vk, x, fake_prf)</code> evaluates to <code>true</code> without knowledge of the secret <code>w</code>.</p>
<p>Thus actually running the generator requires a very secure process to make sure no-one learns about and saves the parameter anywhere. This was the reason for the extremely elaborate ceremony the Zcash team conducted in order to generate the proving key and verification key, while making sure the “toxic waste” parameter lambda was destroyed in the process.</p>
<h2 id="a-zk-snark-for-our-example-program"><a class="header" href="#a-zk-snark-for-our-example-program">A zk-SNARK for our example program</a></h2>
<p>How would Alice and Bob use a zk-SNARK in practice in order for Alice to prove that she knows the secret value in the example above?</p>
<p>First of all, as discussed above we will use a program defined by the following function:</p>
<pre><code class="language-js">function C(x, w) {
  return ( sha256(w) == x );
}
</code></pre>
<p>The first step is for Bob to run the generator <code>G</code> in order to create the proving key <code>pk</code> and verification key <code>vk</code>. This is done by first randomly generating <code>lambda</code> and using that as input:</p>
<p><code>(pk, vk) = G(C, lambda)</code></p>
<p>As discussed above, the parameter <code>lambda</code> must be handled with care, since if Alice learns the value of lambda she will be able to create *<strong>fake proofs</strong>. Bob will share <code>pk</code> and <code>vk</code> with Alice.</p>
<p>Alice will now play the role of the prover. She needs to prove that she knows the value <code>s</code> that hashes to the known hash <code>H</code>. She runs the proving algorithm <code>P</code> using the inputs <code>pk</code>, <code>H</code> and <code>s</code> to generate the proof prf:</p>
<pre><code class="language-js">prf = P(pk, H, s)
</code></pre>
<p>Next Alice presents the proof <code>prf</code> to Bob who runs the verification function <code>V(vk, H, prf)</code> which would return <code>true</code> in this case since Alice properly knew the secret <code>s</code>. Bob can be confident that Alice knew the secret, but Alice did not need to reveal the secret to Bob.</p>
<img src="zkp/snarks/../assets/zk-snarks-flow.png" alt="zk-snarks-flow" style="width:60%; display: block; margin-left: auto;  margin-right: auto;"><div style="break-before: page; page-break-before: always;"></div><h1 id="demo-with-zkcrypto-bellman"><a class="header" href="#demo-with-zkcrypto-bellman">Demo with zkcrypto bellman</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
